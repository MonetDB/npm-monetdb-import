{
  "name": "monetdb-import",
  "version": "0.1.1",
  "description": "MonetDB data import made easy and interactive.",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/MonetDB/npm-monetdb-import.git"
  },
  "keywords": [
    "monetdb",
    "data",
    "import",
    "csv"
  ],
  "author": {
    "name": "R. Cijvat",
    "email": "robin.cijvat@monetdbsolutions.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/MonetDB/npm-monetdb-import/issues"
  },
  "dependencies": {
    "monetdb": "~0.2.1",
    "q": "~1.0.1",
    "csv-sniffer": "0.0.3"
  },
  "readme": "# monetdb-import\n[![Build Status](https://travis-ci.org/MonetDB/npm-monetdb-import.svg)](https://travis-ci.org/MonetDB/npm-monetdb-import)\n[![npm version](https://badge.fury.io/js/monetdb-import.svg)](http://badge.fury.io/js/monetdb-import)\n\nThis module provides an easy API for loading data files into [MonetDB](https://www.monetdb.org).\n\nIf you want to import data with [MonetDB](https://www.monetdb.org), then the [bulk input](https://www.monetdb.org/Documentation/Manuals/SQLreference/CopyInto) normally is the way to go. This however requires you to know what your data files look like. You have to know the delimiters, newline characters, quote characters, the number of lines in the file, whether or not header labels can be found on the first row, and so on. Other than that, you also have to manually create a table that will be used to store your file. For that you have to know the column types, column names, etc. That can be quite annoying.\n\nThis module has been designed to do all of this for you. It is able to do this by using the [csv-sniffer](https://www.npmjs.org/package/csv-sniffer) module. Furthermore, it uses the [MonetDB connector for NodeJS](https://www.npmjs.org/package/monetdb) to interact with your database.\n\nThe **monetdb-import** module takes a delimited text file (binaries not supported), figures out its details, creates appropriate storage for it inside your [MonetDB](https://www.monetdb.org) database and then imports it in there. It literally does **everything**. It is similar to the [Python MonetDB importer](http://homepages.cwi.nl/~hannes/importer.py), but then written in NodeJS, and with more flexibility in terms of specifying the import parameters.\n\n# Installation\nnpm install [-g] monetdb-import\n\n# Dependencies\nThis module depends on the following modules:\n- [monetdb](https://www.npmjs.org/package/monetdb): Necessary for creating a connection to a [MonetDB](https://www.monetdb.org) server process\n- [q](https://www.npmjs.org/package/q): The flow of callbacks can get quite complex inside this module, so therefore we chose to use q functionality inside our code to make for a clear programming style.\n- [csv-sniffer](https://www.npmjs.org/package/csv-sniffer): Necessary for auto detection of crucial file information that we need to import files into [MonetDB](https://www.monetdb.org).\n\n# Usage\nBasically, you can use two approaches in using the **monetdb-import** module.\n\n1. Let the **monetdb-import** module do everything for you. This will work for most of the files. However, in case sniffing fails to find the right parameters, data might end up in the database other than you would expect it to.\n2. Use the **monetdb-import** module in an interactive fashion. You will get passed back the outcome of the [csv-sniffer module](https://www.npmjs.org/package/csv-sniffer). In case you are unhappy with this result, you can tweak the parameters and do another round of sniffing. This process continues until you are happy with the parameters you have found and at that point you can let the **monetdb-import** do the actual import. This approach is extremely useful for, but of course not limited to, building (web)applications that allow users to interactively import their files into the database.\n\n\n### Simple example\nThis example demonstrates the easiest possible use of this module. It passes database connection details, a file to import, and a table name that will be created to the Importer constructor. The import process is then started by calling the import method, which calls a callback on completion.\n```\nvar Importer = require('monetdb-import')();\n\nvar dbOptions = {\n\tdbname: 'demo'\n}\n\nvar imp = new Importer(dbOptions, '/path/to/my/file', 'fancy_table_name');\n\nimp.import(function(err) {\n\tif(err) {\n\t\tconsole.log('Could not import file /path/to/my/file; Reason: '+err);\n\t}\n\n\tconsole.log('File /path/to/my/file successfully imported into database table fancy_table_name');\n});\n\n```\n\n### <a name=\"interactive\"></a>Interactive example\nThis example demonstrates how you can interactively add a file to the database. The Importer object can be constructed in the same way as in the previous example, but instead of immediately calling import, you can call a sniffing function iteratively, until you are happy with its result and then pass this result to the import function to finish the import process.\n\n```\nvar Importer = require('monetdb-import')();\n\nvar dbOptions = {\n\tdbname: 'demo',\n}\n\nvar imp = new Importer(dbOptions, '/path/to/my/file', 'fancy_table_name');\n\nvar sniffOptions = { /* Some optional initial sniffing options */ }\nimp.sniff(sniffOptions, function(err, sniffResult) {\n\tif(err) throw new Error(err);\n\n\t// Investigate sniffResult here...\n\n\t// If we decide that we are not happy with the sniff result, we can\n\t// just do another sniffing round with new options\n\n\tsniffOptions.delimiter = '\\t'; // just an example\n\n\timp.sniff(sniffOptions, function(err, sniffResult) {\n\t\tif(err) throw new Error(err);\n\n\t\t// Let's assume that we are happy with the sniff result now\n\t\t// We can then finish the import process\n\t\timp.import(sniffResult, function(err) {\n\t\t\tif(err) {\n\t\t\t\tconsole.log('Could not import file /path/to/my/file; Reason: '+err);\n\t\t\t}\n\n\t\t\tconsole.log('File /path/to/my/file successfully imported into database table fancy_table_name');\n\t\t});\n\t});\n});\n\n```\n\n\n# API\n\n#### <a name=\"importer\"></a>Importer(dbOptions, [importOptions], filepath, [schemaname], tablename, [delimiters])\nConstructor for an Importer object. \n\n- dbOptions [object]: In case you already have a database connection object in your code, you can add a property 'conn' to dbOptions (i.e. dbOptions = {conn: yourConnectionObject}). If the 'conn' property is found, all other properties will be ignored and we will assume the value of the 'conn' property is a valid, opened, MonetDBConnection object. In case this connection is not yet provided with a [q](https://www.npmjs.org/package/q) instance, we will do this for you.\nIn case the 'conn' property is missing, we will instantiate a MonetDBConnection object ourselves and we expect the dbOptions object to contain the properties needed to do so. These properties are given on the module page of the [monetdb module](https://www.npmjs.org/package/monetdb#connect).\n- importOptions [object]: Optional object containing the following optional properties:\n\t- sampleSize [integer]: The maximum number of bytes to read from the import file for the sniffing process. If it is set to <= 0, the whole file contents will be read and fed to the sniffer. This might not be what you want for big files, since the sniffing process can be quite memory intensive. (default: 0 (so by default reads your entire file)).\n  If the importOptions object is omitted entirely, all defaults will be assumed.\n- filepath [string]: The path of the file that will be added to the database. Note that this import module only handles delimited text files, no binaries.\n- schemaname [string]: The name of the [schema](https://www.monetdb.org/Documentation/SQLreference/Schema) to which the file table will be added. Note that importing will fail if the schema does not exist. (default: sys).\n- tablename [string]: The name of the table that will be created in [MonetDB](https://www.monetdb.org) to hold the contents of the given file. Note that importing will fail if the table already exists. \n- delimiters [array]: Array that represents a set of strings that are possible column delimiters. This\nlist of delimiters will be passed to the [csv-sniffer constructor](https://www.npmjs.org/package/csv-sniffer) (default: null)\n\n\n#### <a name=\"sniff\"></a>Importer.sniff([sniffOptions], fn):\nThis method allows you to use this module in an interactive way (see [interactive example](#interactive)).\n\n- sniffOptions [object]: Optional object that will be passed on to the sniff method of the [csv-sniffer](https://www.npmjs.org/package/csv-sniffer) during importing. See the [csv-sniffer API](https://www.npmjs.org/package/csv-sniffer) for details on the possible options. If the sniffOptions are omitted or set to null, everything will be auto-detected by the CSV sniffer.\n- fn [function]: Callback function that will be called whenever the sniffer completes. The first argument of this function is an error message or null on success. On success, the second argument contains the sniff result. For details on the sniff result, see [csv-sniffer sniffresult](https://www.npmjs.org/package/csv-sniffer#sniffresult).\n\n\n#### <a name=\"import\"></a>Importer.import([sniffResult], [fn]):\nThis method does the actual import process.\n\n- sniffResult [object]: If this argument is not provided, the import method collects the sniff data itself by doing an internal call to [Importer.sniff](#sniff). If you do provide this argument, it should be an object as it results from a call to [Importer.sniff](#sniff), i.e. it must follow the format for the [csv-sniffer sniffresult](https://www.npmjs.org/package/csv-sniffer#sniffresult).\n- fn [function]: This callback function gets called when the import completes. If import failed, an error message will be provided as the first argument. On success, this argument will be set to null. If this argument is omitted or set to null, no one will be notified when the import completes.\n\n\n#### <a name=\"prepareLabels\"></a>Importer.prepareLabels(sniffResult, [options]):\nThis is a *STATIC* method, meaning that you can call this method on the Importer constructor without having to create an\nImporter object first. It is used from within every Importer object to transform the labels in the [csv-sniffer sniffresult](https://www.npmjs.org/package/csv-sniffer#sniffresult) into an array of column names suitable for insertion into MonetDB. \n- sniffResult [object]: Object that obeys the conventions of the output of the [csv-sniffer sniffresult](https://www.npmjs.org/package/csv-sniffer#sniffresult)\n- options [object]: Optional options object\n\t- labelFn [function]: The function to use to construct a label out of an index (see [setLabelFn](#setLabelFn) for more details)\n\t- labelTransformFn [function]: The function to use to transform a label into a format suitable for MonetDB (see [setLabelTransformFn](#setLabelTransformFn) for more details)\n\nThe function performs the following operations:\n- Use the records array in the sniff result to determine the max number of columns in any row\n- Extend the labels array to include enough values for the col max found in the previous step,\n  by using the [label fn](#setLabelFn)\n- Apply [label transform fn](#setLabelTransformFn) to all labels\n- Replace any empty values with a label generated with the label fn\n- Extend any duplicate values with '{{value}}(i)'\n\n\n\n\n\n### Advanced configuration\nThe default configuration will in most cases be sufficient. If it is not, you can use the following methods to have full control over the import process.\n\n\n#### <a name=\"setLabelFn\"></a>Importer.setLabelFn(fn):\n\n- fn [function]: Function that will be used to generate a label from a column index. This\nfunction will be used whenever column labels are not on the first row of the import file.\nThis labeling function receives a column index as its only parameter. Default: \n\n```\nfunction labelFn(i) {\n\treturn \"C\"+i;\n}\n```\n  Note that this function **must always** return a value that can be used as a column name in a database. If it fails to follow this convention (e.g. there is a space in there), then the SQL query that will be executed to create a table will fail.\n\n\n#### <a name=\"setLabelTransformFn\"></a>Importer.setLabelTransformFn(fn):\n- fn [function]: Function that is called to make column labels database-ready. This function will only be called when column labels are taken directly from the first row of your file (otherwise, the [Importer.setLabelFn](#setLabelFn) will be called to generate labels). The following default function is used if you do not provide your own function:\n\n```\nfunction labelTransformFn(label) {\n\treturn label.toLowerCase()\n\t\t\t.replace(/\\s/g, \"_\")\n\t\t\t.replace(/'/g, \"\")\n\t\t\t.replace(/\"/g, \"\")\n\t\t\t.replace(/\\n/g, \" | \")\n\t\t\t.replace(/\\r/g, \"\");\n};\n```\n\n\n#### Importer.setSqlLogFn([fn]):\n\n- fn [function]: Sets the SQL logging function called whenever this module executes a SQL query on your database. It receives a single argument: the SQL query that is executed. If omitted or set to null, queries will not be logged. Default function is console.log.\n\n\n# Q Integration\nFor those of you who would like to interface with the monetdb-import module through using promises: we did you a solid. The asynchronous methods in the Importer object ([Importer.sniff](#sniff) and [Importer.import](#import)) have promise-returning variants: Importer.sniffQ and Importer.importQ.\n\n\n\n### Using this module should be a summer breeze. Don't agree? Please report any suggestions/bugs to robin.cijvat@monetdbsolutions.com\n",
  "readmeFilename": "README.md",
  "gitHead": "5c210d3c2cb115acb0938706e58368bd6f4fc1e7",
  "homepage": "https://github.com/MonetDB/npm-monetdb-import#readme",
  "_id": "monetdb-import@0.1.0",
  "scripts": {},
  "_shasum": "428cb482e39e848d19b1846803840df681859e72",
  "_from": "monetdb-import@0.1.0"
}
